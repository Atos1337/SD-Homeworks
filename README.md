[Ссылка на диаграмму](https://drive.google.com/file/d/1ugLOWAhoQyYoIes2i5ooCkWwWV5iZhIs/view?usp=sharing)

## Допущения:

* В команде нет переноса строк
* Многопоточность не используется
* Мы никак не меняем окружение баша, в котором наше приложение вызывалось, то есть внешняя программа не будет видеть переменных, которые создавались в нашем приложении

## Описание функции main: 
*   В цикле считываем строку `line`, например, с помощью `readLine`
    *   Делаем подстановки в `line`, вызывая метод `Substitutor::substitute`.
    *   Далее вызываем метод `Parser::parseCommands` получаем `List<String>`.
    *   Далее вызываем метод `CommandFactory::getCommand` на каждом элементе листа и получаем `List<Command>`.
    *   Далее создаём файлы `.cli_input`, `.cli_output`
    *   Создаём два `File` от этих двух файлов и передаём `inputStream` от первого, как `in`, а `outputStream` от второго, как `out` и вызываем `Command::execute`.
    *   Если код возврата не `ReturnCode::SUCCESS`, то заканчиваем выполнение программы, иначе
    *   Свапаем `File` и снова повторяем два предыдущих шага, пока команды не кончатся.
    *   После while копируем содержимое `.cli_output` в `stdout`.

## Command 
Интерфейс, от которого будут наследоваться другие команды 
```kotlin    
enum ReturnCode {
    EXIT,
    ERROR,
    SUCCESS
}

interface Command(private args: List<Token>) {
    execute(in: Stream, out: Stream, error: Stream): ReturnCode
};
```

## CommandFactory 
```kotlin
object CommandFactory {
    Map<String, (List<Token>) -> Command> supportedCommands;
    getCommand(line: String): Command {...}
}
```
1. Вызывает `Parser::parseCommand` и получаем имя команды и лист аргументов.
2. Если имя команды есть в supportedCommands, то мы вызываем соответствующий конструктор, иначе
3. Если имя команды содержит `=` и имя команды не было в кавычках, то это команда присваивания и мы вызываем метод `Parser::parseAssignmentCommand`, получая аргументы команды присваивания и создаём `AssignmentCommand`, иначе
4. Это внешняя команда и мы объединяем аргументы с названием команды и передаем их в конструктор `ExternalCommand`.

## State 
Хранит состояние системы, реализовано через глобальный Singleton.

```kotlin
object State {
    Map<String, String> enviromentVariables
}
```


## Substitution
Класс, который отвечает за подстановку глобальных перменных
```kotlin
object Substitutor {
    substitute(line: String): String {...}
}
```

**План реализации**: 
1.  Последовательно находим места подстановки: Если увидели не экранированный доллар не в одинарных кавычках, жадно собираем имя переменной окружения до символа, которого не может быть в имени переменной. Одновременно с эти наращиваем текущий префикс готовой строки `result`.
2.  Собрав имя, достаём значение переменной из `State`, если его там не было, то пустую строку.
3.   Потом делаем `result += value`
4.   Возвращаем `result`

## Token
Класс для токена. Имеет одно из трех состояний: 
* одинарные кавычки
* двойные 
* не в кавычках

## Parser
Класс, отвечает за парсинг строки, которая пришла от пользователя.
* `fun parseCommands(input: String): List<String>`: сплиттим input по `|`, которые не в кавычках.
* `fun parseCommand(input: String) : Pair<Token, List<Token>>`: подстроку разбивает на имя команды и список аргументов
* `fun parseAssignmentCommand(input: String) : List<Token>` разбивает подстроку на имя переменной и ее значение

## Команды
Детали внутренней реализации команд:
### Общее

* В поток ошибок пишем исключение, если оно вылетело и возвращаем `ReturnCode::ERROR`.
* В случае успеха возвращаем `ReturnCode::SUCCESS`.
### cat
* Открываем файлы из аргументов и пишем их последовательно в поток вывода.
* Поток ввода игнорируем, если есть аргументы.

### echo
* Пишем аргументы в вывода последовательно через пробел.

### wc
* Выводит кол-во строк, слов, байт с помощью forEach.
* Если нет аргументов, то поток ввода считаем как файл.

### pwd
* Выводит текущую директорию
* Поток ввода игнорируем. 

### exit
* Возвращаем `ReturnCode::EXIT`.
* Поток ввода игнорируем. 
* В поток вывода ничего не пишем.

### AssignmentCommand
* Если кол-во аргументов не равно 2, то ошибка, иначе первый аргумент - ключ, второй - значение.
* Далее добавляем значение в мапу `State` по данному ключу.

### ExternalCommand
* Используем ProcessBuilder.
