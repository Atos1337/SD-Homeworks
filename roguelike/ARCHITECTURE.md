## Общие сведения о системе

### Описание игры:
* поддерживаем смену локаций(заходим в комнату)
* двумерная карта, состоит из клеток
* есть генерация карты
* есть стены, противники, предметы
* на стены нельзя заходить
* 1 игрок, ходит по клеткам
* есть инвентарь: предметы
* есть возможность убивать монстров
* монстры могут наносить нам урон
* если игровой персонаж умер, то игра начинается заново
* Пошаговая: ничего не меняется, если нет ввода от пользователя.

## Слои в архитектуре:
* ввод пользователя
* Logic
* GUI
    * Инвентарь
    * Карта
    * Инструкции
    * Персонаж
* Model
    * Инвентарь
    * Карта
    * Инструкции
    * Персонаж


## Ключевые требования (architectural drivers)
- мультиплатформенность
- возможность добавления разных языков

## Роли и случаи использования

- Типичный пользователь: Вова, представитель более старшего поколения (30-45 лет), любящий олдскульную консольную графику и нелюбящий казуальщину. Скорее всего, гик, так как игра однопользовательская и значит непопулярна в нынешних реалиях.

- Сценарий использования: Вова приходит после работы, поговорил с женой и детьми и решил пройти уровень в нашей прекрасной игре (один или всей семьей). После игры, если умер, то начал заново с рандомной карты, если нет, то пошел спать.

## Композиция

- Архитектуру выбрали слоистую, потому что наша архитектура хорошо делится на слои, но при этом она более расширяема, чем обычный MVC.
  Диаграмма компонент: https://drive.google.com/file/d/1ddz7-SiaGhij1iucSZbKCaXODO9mGBGw/view?usp=sharing

- Диаграмма состоит из 4х слоев, первый слой отвечает за считывание данных, второй отвечает за  логику и функциональность сущностей, третий слой отвечает за отображение сущностей и последний слой отвечает за хранение информации о сущностях.

## Логическая структура


### Input
- Класс InputProcessor считывает ввод пользователя и в зависимости от кнопки, нажатой пользователем, вызывает соответствующий метод LogicFacade.
### Logic
  https://drive.google.com/file/d/1bV6EcTbEd8aW0aVcDHciq7vDdPQQ3i6G/view?usp=sharing

- Класс LogicFaсade хранит состояние и определяет к какой сущности обращается пользователь, имеет методы для обработки действий. Все классы логики для каждой сущности наследуются от интерфейса Logic, который содержит методы для обработки действий пользователя и отрисовки сущности.

### Model
https://drive.google.com/file/d/1WvhdbsDgOOYU3rsElY9ul49OPPVi-kF6/view?usp=sharing

- Для каждой сущности свой класс, который хранит поля с информацией об этой сущности, а также имеет геттеры и сеттеры.
  Для карты хранится список всех клеток, и методы которые позволяют менять клетки и загружать карту.
  Для инструкций хранятся константные поля в которых хранятся название инструкции и ее описание и авторы.
  Для  инвентаря хранится список его элементов и методы которые позволяют его изменять.

- Item. Это интерфейс, от которого мы будем наследовать наши предметы, внутри будет хранится их состояние и функциональность. У Item есть абстрактный метод use, который принимает состояние персонажа, этот метод как раз таки и отвечает за функциональность:
    - яблоко – повышение здоровья
    - доспехи – увеличение брони

- Также мы от Item наследовали два интерфейса: Disposable и NonDisposable – элементы, которые исчезают из инвентаря при использовании, и элементы, которые нет, соответственно
- Есть абстрактный класс Character, который символизирует собой любую живую сущность: количество здоровья, наносимого урона, мощность брони. Также есть метод атаковать другого персонажа.
  От Character мы наследуем два класса живых существ, которые мы сейчас используем в нашей игре: PlayerCharacter и NPC


### GUI
https://drive.google.com/file/d/1fgEZ-A2HVXgz220mMKunQudRTtRFs2kn/view?usp=sharing

Интерфейс GUI с методом draw(), от которого наследуются классы для каждой сущности, каждый с единственным методом draw(), который отвечает за отрисовку данной сущности.
* `draw()` в MapGUI -- отрисовывает карту
* ```draw()``` в InventoryGUI -- отрисовывает инвентаре
* ```draw()``` в InstructionsGUI -- отрисовывает инструкци

CharacterGUI отрисовывается в окне поля, снизу, показывает hp, атаку, отрисовку вызывает MapGUI.





## Взаимодействия и состояния (диаграммы последовательностей и конечных автоматов и их текстовое описание — даже если для вашей архитектуры они не очень полезны, нарисуйте,потренироваться).
https://drive.google.com/file/d/1at57KtKZsUX42IS_3tCQXKzUlNzkBmTd/view?usp=sharing

* Пользователь по нажатию кнопки может переключать окна Карта, Инвентарь, Подсказка.
* Герой может попробовать пойти на клетку. Если это стена, то он не переходит на нее. Если это монстр, то он бьет его. Иначе переходит наклетку и если там лежит предмет, то может его взять. Если умер в бою, то переродился и начал заново.

## Алгоритм генерации поля

- Сначала наше поле состоит сугубо из стен. Запускаем на нем алгоритм Random Walk, и получившийся путь “прогулки” заполняем клетками, по которым можно ходить

- Хочется, чтобы карта была более реальной, поэтому предлагается также рандомить шаг для на каждой итерации Random Walk

- Далее произвольным образом расставляем по карте предметы и монстров. Хочется, чтобы предметы были расположены более менее разряжено. Поэтому предлагаю такой подход: для каждого клетки будет какая-то вероятность появления появления в ней предмета. После того, как мы расположили в какой-то клетке предмет, мы балансируем вероятности  по следующей логике: клетки, который находятся ближе к клеткам с предметами, получают меньшую вероятность

## Управление

- Навигация персонажа по карте осуществляется через клавиатуру, а именно через клавиши стрелочек:
    - Клавиша влево – движение влево
    - Клавиша вправо – движение вправо
    - Клавиша вверх – движение вперед
    - Клавиша вниз – движение вниз

- Взаимодействие с миром. На данном этапе мы выделяем только две формы взаимодействия с внешним миром:
    - Взаимодействие с предметами: можно брать и оставлять предмет на игровой клетки
    - Взаимодействие с монстрами: их можно бить и всячески над ними издеваться

# Аналоги

* Нашу консольную игру мы решили реализовывать на языке Kotlin. Для работой с консолью мы используем библиотеку lanterna. Мы также рассматривали аналоги данной библиотеки, такие как: javacurses. Их самой главной проблемой оказалась старость это выражалось в том, что эти библиотеки уже давно никто не поддерживает. Также еще одно преимущество lanterna это документация и много уроков в интернете.

* Также выбор языка стал очень большой проблемой для нас. Мы думали над четырьмя языками, которые узнали при обучении в нашем замечательном университете: C++, Haskell, Java, Kotlin.
    *   Мы сразу отказались от Java, так как это очень консервативный язык.
    *   Хотят у нас и был опыт с ncurses, но мы не взяли плюсы, потому что имеем опыт с прострелом ног
    *   Также мы очень долго рассматривали Haskell, но решили отказаться от него, потому что мыло людей на этой планете понимают всю его красоту
    *   Поэтому мы выбрали языка Kotlin

* Архитектуру выбрали слоистую, потому что наша архитектура хорошо делится на слои, но при этом она более расширяема, чем обычный MVC.


